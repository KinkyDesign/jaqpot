// /**
//  * Jaqpot API
//  * Jaqpot v4 (Quattro) is the 4th version of a YAQP, a RESTful web service which can be used to train machine learning models and use them to obtain toxicological predictions for given chemical compounds or engineered nano materials. The project is written in Java8 and JEE7.
//  *
//  * OpenAPI spec version: 4.0.3
//  * Contact: hampos@me.com
//  *
//  * NOTE: This class is auto generated by the swagger code generator program.
//  * https://github.com/swagger-api/swagger-codegen.git
//  * Do not edit the class manually.
//  */

// /* tslint:disable:no-unused-variable member-ordering */

// import { Inject, Injectable, Optional }                      from '@angular/core';
// import { Http, Headers, URLSearchParams }                    from '@angular/http';
// import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
// import { Response, ResponseContentType }                     from '@angular/http';

// import { Observable }                                        from 'rxjs/Observable';
// import '../rxjs-operators';

// import { Feature } from '../model/feature';

// import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
// import { Configuration }                                     from '../configuration';


// @Injectable()
// export class FeatureService {

//     protected basePath = 'http://dev.jaqpot.org:8081/jaqpot/services';
//     public defaultHeaders: Headers = new Headers();
//     public configuration: Configuration = new Configuration();

//     constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
//         if (basePath) {
//             this.basePath = basePath;
//         }
//         if (configuration) {
//             this.configuration = configuration;
// 			this.basePath = basePath || configuration.basePath || this.basePath;
//         }
//     }

//     /**
//      *
//      * Extends object by coping non-existing properties.
//      * @param objA object to be extended
//      * @param objB source object
//      */
//     private extendObj<T1,T2>(objA: T1, objB: T2) {
//         for(let key in objB){
//             if(objB.hasOwnProperty(key)){
//                 (objA as any)[key] = (objB as any)[key];
//             }
//         }
//         return <T1&T2>objA;
//     }

//     /**
//      * @param consumes string[] mime-types
//      * @return true: consumes contains 'multipart/form-data', false: otherwise
//      */
//     private canConsumeForm(consumes: string[]): boolean {
//         const form = 'multipart/form-data';
//         for (let consume of consumes) {
//             if (form === consume) {
//                 return true;
//             }
//         }
//         return false;
//     }

//     /**
//      * Creates a new Feature
//      * Creates a new feature which is assigned a random unique ID. When creating a new feature, clients must wary not only for its syntactic correctness, but also for its semantic completeness. It is strongly recommended to add a comprehensive and identifying title to your feature using the &lt;code&gt;meta.titles&lt;/code&gt; field, to add a description in &lt;code&gt;meta.descriptions&lt;/code&gt; and also to add a list of tags in &lt;code&gt;meta.subjects&lt;/code&gt; that will facilitate the discoverability of your features later. Additionally, all features should be annotated with appropriate ontological classes (from the OpenTox ontology), such as &lt;code&gt;ot:Feature&lt;/code&gt;, &lt;code&gt;ot:NumericFeature&lt;/code&gt; and &lt;code&gt;ot:NominalFeature&lt;/code&gt;. Features that are created as prediction features for a model or are descriptors that can be calculated using a descriptor calculation web service should be linked to this/these service(s) using &lt;code&gt;meta.hasSources&lt;/code&gt;. Finally, nominal features should define their admissible values in &lt;code&gt;admissibleValues&lt;/code&gt;. Malformed feature documents will not be accepted by the server and an error report will be generated and returned to the client. Notice also that authentication, authorization and accounting restrictions may apply.
//      * @param body Feature in JSON representation compliant with the Feature specifications. Malformed Feature entries with missing fields will not be accepted.
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public createFeature(body: Feature, subjectid?: string, extraHttpRequestParams?: any): Observable<{}> {
//         return this.createFeatureWithHttpInfo(body, subjectid, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Deletes a particular Feature resource.
//      * Deletes a Feature of a given ID. The method is idempondent, that is, it can be used more than once without triggering an exception/error. If the Feature does not exist, the method will return without errors. Authentication and authorization requirements apply, so clients that are not authenticated with a valid token or do not have sufficient priviledges will not be able to delete a Feature using this method.
//      * @param id ID of the Model.
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public deleteFeature(id: string, subjectid?: string, extraHttpRequestParams?: any): Observable<{}> {
//         return this.deleteFeatureWithHttpInfo(id, subjectid, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Finds Feature by ID
//      * Finds specified Feature (by ID)
//      * @param id
//      * @param subjectid Authorization token
//      */
//     public getFeature(id: string, subjectid?: string, extraHttpRequestParams?: any): Observable<Feature> {
//         return this.getFeatureWithHttpInfo(id, subjectid, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Lists features
//      * Lists Feature entries in the DB of Jaqpot and returns them in a list. Results can be obtained either in the form of a URI list or as a JSON list as specified by the Accept HTTP header. In the latter case, a list will be returned containing only the IDs of the features, their metadata and their ontological classes. The parameter max, which specifies the maximum number of IDs to be listed is limited to 500; if the client specifies a larger value, an HTTP Warning Header will be returned (RFC 2616) with code P670.
//      * @param subjectid Authorization token
//      * @param query Generic query
//      * @param start start
//      * @param max max - the server imposes an upper limit of 500 on this parameter.
//      */
//     public listFeatures(subjectid?: string, query?: string, start?: number, max?: number, extraHttpRequestParams?: any): Observable<{}> {
//         return this.listFeaturesWithHttpInfo(subjectid, query, start, max, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }

//     /**
//      * Places a new Feature at a particular URI
//      * Creates a new Feature entry at the specified URI. If a Feature already exists at this URI,it will be replaced. If, instead, no Feature is stored under the specified URI, a new Feature entry will be created. Notice that authentication, authorization and accounting (quota) restrictions may apply.
//      * @param id ID of the Feature.
//      * @param body Feature in JSON
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public putFeature(id: string, body: Feature, subjectid?: string, extraHttpRequestParams?: any): Observable<{}> {
//         return this.putFeatureWithHttpInfo(id, body, subjectid, extraHttpRequestParams)
//             .map((response: Response) => {
//                 if (response.status === 204) {
//                     return undefined;
//                 } else {
//                     return response.json() || {};
//                 }
//             });
//     }


//     /**
//      * Creates a new Feature
//      * Creates a new feature which is assigned a random unique ID. When creating a new feature, clients must wary not only for its syntactic correctness, but also for its semantic completeness. It is strongly recommended to add a comprehensive and identifying title to your feature using the &lt;code&gt;meta.titles&lt;/code&gt; field, to add a description in &lt;code&gt;meta.descriptions&lt;/code&gt; and also to add a list of tags in &lt;code&gt;meta.subjects&lt;/code&gt; that will facilitate the discoverability of your features later. Additionally, all features should be annotated with appropriate ontological classes (from the OpenTox ontology), such as &lt;code&gt;ot:Feature&lt;/code&gt;, &lt;code&gt;ot:NumericFeature&lt;/code&gt; and &lt;code&gt;ot:NominalFeature&lt;/code&gt;. Features that are created as prediction features for a model or are descriptors that can be calculated using a descriptor calculation web service should be linked to this/these service(s) using &lt;code&gt;meta.hasSources&lt;/code&gt;. Finally, nominal features should define their admissible values in &lt;code&gt;admissibleValues&lt;/code&gt;. Malformed feature documents will not be accepted by the server and an error report will be generated and returned to the client. Notice also that authentication, authorization and accounting restrictions may apply.
//      * @param body Feature in JSON representation compliant with the Feature specifications. Malformed Feature entries with missing fields will not be accepted.
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public createFeatureWithHttpInfo(body: Feature, subjectid?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/feature';

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'body' is not null or undefined
//         if (body === null || body === undefined) {
//             throw new Error('Required parameter body was null or undefined when calling createFeature.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }


//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];


//         headers.set('Content-Type', 'application/json');

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Post,
//             headers: headers,
//             body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Deletes a particular Feature resource.
//      * Deletes a Feature of a given ID. The method is idempondent, that is, it can be used more than once without triggering an exception/error. If the Feature does not exist, the method will return without errors. Authentication and authorization requirements apply, so clients that are not authenticated with a valid token or do not have sufficient priviledges will not be able to delete a Feature using this method.
//      * @param id ID of the Model.
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public deleteFeatureWithHttpInfo(id: string, subjectid?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/feature/${id}'
//                     .replace('${' + 'id' + '}', String(id));

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'id' is not null or undefined
//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling deleteFeature.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }


//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];


//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Delete,
//             headers: headers,
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Finds Feature by ID
//      * Finds specified Feature (by ID)
//      * @param id
//      * @param subjectid Authorization token
//      */
//     public getFeatureWithHttpInfo(id: string, subjectid?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/feature/${id}'
//                     .replace('${' + 'id' + '}', String(id));

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'id' is not null or undefined
//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling getFeature.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }


//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];


//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Get,
//             headers: headers,
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Lists features
//      * Lists Feature entries in the DB of Jaqpot and returns them in a list. Results can be obtained either in the form of a URI list or as a JSON list as specified by the Accept HTTP header. In the latter case, a list will be returned containing only the IDs of the features, their metadata and their ontological classes. The parameter max, which specifies the maximum number of IDs to be listed is limited to 500; if the client specifies a larger value, an HTTP Warning Header will be returned (RFC 2616) with code P670.
//      * @param subjectid Authorization token
//      * @param query Generic query
//      * @param start start
//      * @param max max - the server imposes an upper limit of 500 on this parameter.
//      */
//     public listFeaturesWithHttpInfo(subjectid?: string, query?: string, start?: number, max?: number, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/feature';

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         if (query !== undefined) {
//             queryParameters.set('query', <any>query);
//         }

//         if (start !== undefined) {
//             queryParameters.set('start', <any>start);
//         }

//         if (max !== undefined) {
//             queryParameters.set('max', <any>max);
//         }

//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }


//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];


//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Get,
//             headers: headers,
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

//     /**
//      * Places a new Feature at a particular URI
//      * Creates a new Feature entry at the specified URI. If a Feature already exists at this URI,it will be replaced. If, instead, no Feature is stored under the specified URI, a new Feature entry will be created. Notice that authentication, authorization and accounting (quota) restrictions may apply.
//      * @param id ID of the Feature.
//      * @param body Feature in JSON
//      * @param subjectid Clients need to authenticate in order to create resources on the server
//      */
//     public putFeatureWithHttpInfo(id: string, body: Feature, subjectid?: string, extraHttpRequestParams?: any): Observable<Response> {
//         const path = this.basePath + '/feature/${id}'
//                     .replace('${' + 'id' + '}', String(id));

//         let queryParameters = new URLSearchParams();
//         let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

//         // verify required parameter 'id' is not null or undefined
//         if (id === null || id === undefined) {
//             throw new Error('Required parameter id was null or undefined when calling putFeature.');
//         }
//         // verify required parameter 'body' is not null or undefined
//         if (body === null || body === undefined) {
//             throw new Error('Required parameter body was null or undefined when calling putFeature.');
//         }
//         if (subjectid !== undefined && subjectid !== null) {
//             headers.set('subjectid', String(subjectid));
//         }


//         // to determine the Accept header
//         let produces: string[] = [
//             'application/json',
//             'text/uri-list'
//         ];


//         headers.set('Content-Type', 'application/json');

//         let requestOptions: RequestOptionsArgs = new RequestOptions({
//             method: RequestMethod.Put,
//             headers: headers,
//             body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
//             search: queryParameters,
//             withCredentials:this.configuration.withCredentials
//         });
//         // https://github.com/swagger-api/swagger-codegen/issues/4037
//         if (extraHttpRequestParams) {
//             requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
//         }

//         return this.http.request(path, requestOptions);
//     }

// }
